import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

class PSNR(nn.Module):
    """
    Implementation of PSNR Calculation for image tensors.
    """
    def __init__(self, maximum_pixel_value=1.0): 
        """
        Initializes the PSNR Calculation module. 

        Args: 
            maximum_pixel_value (float): maximum pixel value of the input tensors for PSNR calculation.
        """
        super().__init__()
        self.me_loss = nn.MSELoss()
        self.max_value = maximum_pixel_value

    def forward(self, clean_img, sr_img): 
        """
        Computes the Peak Signal-to-Noise Ratio (PSNR) between the clean (reference) image and the 
        super-resolved (SR) image. 

        Args:
            clean_img (torch.Tensor): The ground truth image.
            sr_img (torch.Tensor): The super-resolved image generated by the model.

        Returns:
            torch.Tensor: The PSNR value.
        """
        mse_loss = self.me_loss(clean_img, sr_img) 
        psnr_value = 10 * torch.log10(self.max_value ** 2 / mse_loss)
        return psnr_value

class SSIM(nn.Module):
    def __init__(self, constants=(0.0001, 0.0001)):
        """
        Initializes the SSIM calculation Module. 

        Args: 
            constants (Tuple[Int, Int]): Constants (C1, C2) for stablizing SSIM calculation.
        """
        super().__init__()
        self.C1 = constants[0]
        self.C2 = constants[1]

    def channel_calculation(self, x, y):
        """
        Computes SSIM for a single channel of the images.

        Args:
            x (torch.Tensor): The first image channel.
            y (torch.Tensor): The second image channel.

        Returns:
            torch.Tensor: The SSIM value for the given channel.
        """
        mean_x = torch.mean(x)
        mean_y = torch.mean(y)
        
        variance_x = torch.var(x, unbiased=False)
        variance_y = torch.var(y, unbiased=False)
        
        covariance_xy = torch.mean((x - mean_x) * (y - mean_y))
        
        SSIM = ((2 * mean_x * mean_y + self.C1) * (2 * covariance_xy + self.C2)) / ((mean_x ** 2 + mean_y ** 2 + self.C1) * (variance_x + variance_y + self.C2))
        
        return SSIM

    def channel_splits(self, x, y):
        """
        Splits the images into individual channels and returns them as separate tensors.

        Args:
            x (torch.Tensor): The first image tensor with shape (N, C, H, W).
            y (torch.Tensor): The second image tensor with shape (N, C, H, W).

        Returns:
            (List[torch.Tensor], List[torch.Tensor]): Two lists containing the channels of x and y, respectively.
        """
        assert x.shape[1] == y.shape[1], "[ERROR] X and Y have different number of channels."

        x_tensors = []
        y_tensors = []

        for i in range(x.shape[1]):
            x_tensors.append(x[:, i, :, :])
            y_tensors.append(y[:, i, :, :])
        
        return x_tensors, y_tensors
    
    def forward(self, clean_img, sr_img):
        """
        Computes Structural Similarity Index (SSIM) between the clean (reference) image and the 
        super-resolved (SR) image.

        Args: 
            clean_img (torch.Tensor): The ground truth image.
            sr_img (torch.Tensor): The super-resolved image generated by the model.
        
        Returns: 
            torch.Tensor: The SSIM value

        """
        x_tensors, y_tensors = self.channel_splits(clean_img, sr_img)

        SSIM_values = 0.0
        for x, y in zip(x_tensors, y_tensors):
            SSIM_values += self.channel_calculation(x, y)
        
        return 1 - SSIM_values / len(x_tensors) 
    
class MSE_Loss(nn.Module):
    def __init__(self): 
        """
        Initializes MSE Calculation module.
        """
        super().__init__()

    def forward(self, x, y): 
        """
        Compute the Mean Square Error (MSE) Loss between x and y 
        
        Args: 
            x (torch.Tensor): The x tensor containing the same dimensions as y 
            y (torch.Tensor): The y tensor containing the same dimensions as x
        
        Returns:
            torch.Tensor: The Mean Squared Error Loss between x and y.

        """
        difference = x - y 
        return torch.mean(difference ** 2)